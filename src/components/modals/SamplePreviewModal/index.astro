---
// src/components/cards/SamplePreviewModal/index.astro

/**
 * SamplePreviewModal — mobile-first, a11y-safe modal for sample previews
 * Props:
 *  - open: boolean
 *  - title: string
 *  - before: string
 *  - after: string
 *  - media?: { src: string; alt: string } | null
 *
 * Consumers control `open` via parent state.
 * The modal emits a `sample-preview:close` CustomEvent on close so parents
 * can synchronise state.
 */
import "./SamplePreviewModal.css";

interface Media {
  src: string;
  alt: string;
}

interface Props {
  open: boolean;
  title: string;
  before: string;
  after: string;
  media?: Media | null;
}

const { open = false, title, before, after, media = null } =
  Astro.props as Props;

// IDs for a11y labels
const dialogId = "sample-preview-modal";
const titleId = "sample-preview-title";
const descId = "sample-preview-desc";

/**
 * Split a raw text block into "points" suitable for bullets.
 * - Treats line breaks and "•" as explicit separators.
 * - Further splits into sentences on ., !, ? while keeping punctuation.
 * - Trims and removes empty fragments.
 */
function splitToPoints(value: string): string[] {
  if (!value) return [];

  // Normalise explicit bullet markers into line breaks
  const lineChunks = value
    .replace(/•/g, "\n")
    .split(/[\r\n]+/)
    .map((chunk) => chunk.trim())
    .filter(Boolean);

  const points: string[] = [];

  lineChunks.forEach((chunk) => {
    if (!chunk) return;

    let buffer = "";

    for (let i = 0; i < chunk.length; i++) {
      const char = chunk[i];
      const next = chunk[i + 1];
      buffer += char;

      const isSentenceEnd =
        (char === "." || char === "!" || char === "?") &&
        (next === " " || next === undefined);

      if (isSentenceEnd) {
        const sentence = buffer.trim();
        if (sentence.length) {
          points.push(sentence);
        }
        buffer = "";

        // Skip the trailing space after punctuation if present
        if (next === " ") {
          i++;
        }
      }
    }

    const remaining = buffer.trim();
    if (remaining.length) {
      points.push(remaining);
    }
  });

  return points;
}

const beforePoints = splitToPoints(before);
const afterPoints = splitToPoints(after);
---

<div
  class={`spm ${open ? "is-open" : ""}`}
  aria-hidden={open ? "false" : "true"}
  data-section="sample-preview"
>
  <!-- Backdrop -->
  <div class="spm__backdrop" data-close aria-hidden="true"></div>

  <!-- Dialog -->
  <aside
    id={dialogId}
    class="spm__dialog"
    role="dialog"
    aria-modal="true"
    aria-labelledby={titleId}
    aria-describedby={descId}
    tabindex="-1"
  >
    <header class="spm__header">
      <h2 id={titleId} class="spm__title">
        {title}
      </h2>
      <button
        type="button"
        class="spm__close"
        data-close
        aria-label="Close sample preview"
      >
        ×
      </button>
    </header>

    <div id={descId} class="spm__content">
      {media && (
        <figure class="spm__media">
          <img
            src={media.src}
            alt={media.alt}
            loading="lazy"
            decoding="async"
            width="1280"
            height="720"
          />
        </figure>
      )}

      <div class="spm__ba">
        <section class="spm__block spm__block--before">
          <h3 class="spm__eyebrow">Before</h3>

          {beforePoints.length ? (
            <ul class="spm__list">
              {beforePoints.map((point) => (
                <li class="spm__text">{point}</li>
              ))}
            </ul>
          ) : (
            <p class="spm__text">{before}</p>
          )}
        </section>

        <section class="spm__block spm__block--after">
          <h3 class="spm__eyebrow">After</h3>

          {afterPoints.length ? (
            <ul class="spm__list">
              {afterPoints.map((point) => (
                <li class="spm__text">{point}</li>
              ))}
            </ul>
          ) : (
            <p class="spm__text">{after}</p>
          )}
        </section>
      </div>
    </div>
  </aside>

  <!-- framework-free focus trap + close handlers -->
  <script is:inline>
    (function () {
      var scriptEl = document.currentScript;
      if (!scriptEl) return;
      var root = scriptEl.closest(".spm");
      if (!root) return;

      var dialog = root.querySelector(".spm__dialog");
      var closeEls = root.querySelectorAll("[data-close]");

      if (!dialog) return;

      var lastFocused = null;

      function isOpen() {
        return root.classList.contains("is-open");
      }

      function getFocusables() {
        return dialog.querySelectorAll(
          'a[href], button, textarea, input, select, [tabindex]:not([tabindex="-1"])'
        );
      }

      function closeModal() {
        if (!isOpen()) return;

        root.classList.remove("is-open");
        root.setAttribute("aria-hidden", "true");

        // Restore focus to the element that triggered the modal, if possible
        if (
          lastFocused &&
          lastFocused instanceof HTMLElement &&
          document.contains(lastFocused)
        ) {
          try {
            lastFocused.focus();
          } catch (_) {
            // ignore
          }
        }

        // Notify parent so it can update `open` state
        var evt;
        try {
          evt = new CustomEvent("sample-preview:close", {
            bubbles: true,
            cancelable: false,
          });
        } catch (e) {
          // Fallback for very old browsers
          evt = document.createEvent("CustomEvent");
          evt.initCustomEvent("sample-preview:close", true, false, null);
        }
        root.dispatchEvent(evt);
      }

      function handleKeydown(event) {
        if (!isOpen()) return;

        var e = event || window.event;

        if (e.key === "Escape" || e.key === "Esc") {
          e.preventDefault();
          closeModal();
          return;
        }

        if (e.key !== "Tab") return;

        var items = getFocusables();
        if (!items.length) return;

        var first = items[0];
        var last = items[items.length - 1];

        if (e.shiftKey) {
          if (document.activeElement === first) {
            last.focus();
            e.preventDefault();
          }
        } else {
          if (document.activeElement === last) {
            first.focus();
            e.preventDefault();
          }
        }
      }

      // Observe open/close to handle focus
      var observer = new MutationObserver(function (mutations) {
        mutations.forEach(function () {
          if (isOpen()) {
            // Capture the element that opened the modal
            var active = document.activeElement;
            if (active && active !== dialog) {
              lastFocused = active;
            }
            // Move focus into the dialog
            window.setTimeout(function () {
              try {
                dialog.focus();
              } catch (_) {
                // ignore
              }
            }, 0);
            document.addEventListener("keydown", handleKeydown);
          } else {
            document.removeEventListener("keydown", handleKeydown);
          }
        });
      });

      observer.observe(root, { attributes: true, attributeFilter: ["class"] });

      // Backdrop + close button handlers
      closeEls.forEach(function (el) {
        el.addEventListener("click", function () {
          closeModal();
        });
      });
    })();
  </script>
</div>
