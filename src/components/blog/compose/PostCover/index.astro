---
// src/components/blog/compose/PostCover/index.astro
// Fix Plan 190.2 / 193 / 195 – normalise cover prop
// and render a CLS-safe, responsive hero image card with AVIF/WebP support.
//
// Fix Plan 006.1 – OnePath heroImage bridge:
// - BlogPostLayout now calls <PostCover src={heroImage.src} alt={heroImage.alt} />.
// - To stay backwards-compatible, this component now accepts BOTH:
//     • cover={...}   (legacy, full object or Astro image)
//     • src/alt/...   (new heroImage-based call site)
// - All inputs are normalised through a single pipeline so the hero image
//   renders reliably for every article.

import css from "./PostCover.css?url";

interface CoverData {
  /** String path per Fix 195-C (e.g. "/assets/images/blog/<category>/<slug>-hero.webp") */
  src: string;
  alt?: string;
  width?: number;
  height?: number;
  caption?: string;
  credit?: string;
  /**
   * Optional responsive sources for modern formats.
   * Example: "/assets/...-480.avif 480w, /assets/...-768.avif 768w, /assets/...-1200.avif 1200w"
   */
  srcsetAvif?: string;
  srcsetWebp?: string;
  /**
   * Optional sizes attribute override.
   * Default: "(max-width: 768px) 100vw, 1200px"
   */
  sizes?: string;
}

interface PostCoverProps {
  /**
   * Legacy / flexible entry:
   * - a fully-shaped CoverData object
   * - an Astro image-like object with nested src
   * - a plain string path
   * - or undefined (no cover provided)
   */
  cover?: CoverData | string | Record<string, any>;

  /**
   * New FP-006.1 heroImage entry:
   * - When BlogPostLayout passes src/alt from heroImage, we build a cover
   *   object from these scalar props.
   */
  src?: string;
  alt?: string;
  width?: number;
  height?: number;
  caption?: string;
  credit?: string;
  srcsetAvif?: string;
  srcsetWebp?: string;
  sizes?: string;

  /**
   * Optional post title, used as a fallback for alt text.
   */
  title?: string;
}

/**
 * Normalise any incoming cover value into a safe CoverData object.
 * If nothing usable is provided, returns null and no figure is rendered.
 */
function normaliseCover(
  raw: PostCoverProps["cover"],
  titleFallback: string,
): CoverData | null {
  if (!raw) return null;

  // String path
  if (typeof raw === "string") {
    const trimmed = raw.trim();
    if (!trimmed) return null;
    return {
      src: trimmed,
      alt: titleFallback,
    };
  }

  if (typeof raw !== "object") {
    return null;
  }

  // Object with src (might be string or nested object from Astro image)
  const anyRaw = raw as Record<string, any>;

  let src = "";
  let width: number | undefined;
  let height: number | undefined;

  if (typeof anyRaw.src === "string") {
    src = anyRaw.src;
    width =
      typeof anyRaw.width === "number" && Number.isFinite(anyRaw.width)
        ? anyRaw.width
        : undefined;
    height =
      typeof anyRaw.height === "number" && Number.isFinite(anyRaw.height)
        ? anyRaw.height
        : undefined;
  } else if (
    anyRaw.src &&
    typeof anyRaw.src === "object" &&
    typeof anyRaw.src.src === "string"
  ) {
    src = anyRaw.src.src;
    width =
      typeof anyRaw.src.width === "number" &&
      Number.isFinite(anyRaw.src.width)
        ? anyRaw.src.width
        : undefined;
    height =
      typeof anyRaw.src.height === "number" &&
      Number.isFinite(anyRaw.src.height)
        ? anyRaw.src.height
        : undefined;
  }

  if (!src) {
    // No valid src -> treat as no cover, avoid broken layout or runtime errors.
    return null;
  }

  const altSource =
    typeof anyRaw.alt === "string" && anyRaw.alt.trim().length > 0
      ? anyRaw.alt
      : titleFallback;

  const cover: CoverData = {
    src,
    alt: altSource,
    width,
    height,
  };

  if (typeof anyRaw.caption === "string") {
    cover.caption = anyRaw.caption;
  }
  if (typeof anyRaw.credit === "string") {
    cover.credit = anyRaw.credit;
  }
  if (typeof anyRaw.srcsetAvif === "string") {
    cover.srcsetAvif = anyRaw.srcsetAvif;
  }
  if (typeof anyRaw.srcsetWebp === "string") {
    cover.srcsetWebp = anyRaw.srcsetWebp;
  }
  if (typeof anyRaw.sizes === "string") {
    cover.sizes = anyRaw.sizes;
  }

  return cover;
}

const props = Astro.props as PostCoverProps;

const {
  cover: coverProp,
  src,
  alt,
  width,
  height,
  caption,
  credit,
  srcsetAvif: srcsetAvifProp,
  srcsetWebp: srcsetWebpProp,
  sizes: sizesProp,
} = props;

const titleFallback = alt ?? props.title ?? "";

/**
 * Decide what to feed into the normaliser:
 * - If a legacy `cover` prop is present, it wins.
 * - Otherwise, if any of the scalar heroImage props exist, build a cover-like
 *   object from them.
 */
let rawForNormalise: PostCoverProps["cover"] = coverProp;

const hasScalarHeroInput =
  typeof src === "string" && src.trim().length > 0
    ? true
    : Boolean(
        alt ||
          width ||
          height ||
          caption ||
          credit ||
          srcsetAvifProp ||
          srcsetWebpProp ||
          sizesProp,
      );

if (!rawForNormalise && hasScalarHeroInput) {
  rawForNormalise = {
    src: src ?? "",
    alt,
    width,
    height,
    caption,
    credit,
    srcsetAvif: srcsetAvifProp,
    srcsetWebp: srcsetWebpProp,
    sizes: sizesProp,
  } as Record<string, any>;
}

// Normalise incoming cover; may be null if nothing usable provided.
const cover = normaliseCover(rawForNormalise, titleFallback);

// If cover is null, imgSrc will be empty and the figure won’t render.
const imgSrc: string = cover?.src ?? "";

// Width/height are taken from cover; if missing, the browser will infer.
const imgWidth: number | undefined = cover?.width;
const imgHeight: number | undefined = cover?.height;

const imgAlt = cover?.alt || titleFallback || "";
const hasCaption = Boolean(cover && (cover.caption || cover.credit));

// Responsive format sources and sizes
const srcsetAvif = cover?.srcsetAvif;
const srcsetWebp = cover?.srcsetWebp;
const sizesAttr = cover?.sizes || "(max-width: 768px) 100vw, 1200px";
---
<link rel="stylesheet" href={css} />

{imgSrc && (
  <figure
    class="post__cover container postCover"
    data-section="post-cover"
    itemprop="image"
    itemscope
    itemtype="https://schema.org/ImageObject"
  >
    <picture class="postCover__picture">
      {srcsetAvif && (
        <source srcset={srcsetAvif} sizes={sizesAttr} type="image/avif" />
      )}
      {srcsetWebp && (
        <source srcset={srcsetWebp} sizes={sizesAttr} type="image/webp" />
      )}
      <img
        src={imgSrc}
        alt={imgAlt}
        width={imgWidth}
        height={imgHeight}
        loading="eager"
        decoding="async"
        fetchpriority="high"
        itemprop="url"
        sizes={sizesAttr}
      />
    </picture>

    {hasCaption && cover && (
      <figcaption class="postCover__caption">
        {cover.caption && (
          <span class="postCover__captionText">{cover.caption}</span>
        )}
        {cover.credit && (
          <span class="postCover__credit">
            {cover.caption && <span aria-hidden="true"> · </span>}
            {cover.credit}
          </span>
        )}
      </figcaption>
    )}
  </figure>
)}
