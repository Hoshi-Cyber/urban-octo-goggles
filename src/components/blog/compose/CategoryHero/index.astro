---
// File: src/components/blog/compose/CategoryHero/index.astro

import css from "./CategoryHero.css?url";
import {
  getCategory,
  type BlogCategory,
  type CategorySlug,
} from "@/lib/blog/categories";

export interface Cta {
  href: string;
  label: string;
}

export interface Stats {
  postCount?: number;
  lastUpdated?: string | Date;
  readRange?: string; // e.g., "3–7 min"
}

export interface Props {
  /**
   * Optional explicit title.
   * If omitted, the component will derive a title from BlogCategory metadata
   * (heroTitle → name) when categorySlug/category is provided.
   */
  title?: string;
  /**
   * Optional explicit dek/subtitle.
   * If omitted, the component will derive it from BlogCategory metadata
   * (heroSubtitle → description) when categorySlug/category is provided.
   */
  dek?: string;
  stats?: Stats;
  primaryCta?: Cta;
  secondaryCta?: Cta;
  /** Fix Plan 158: avoid double horizontal gutters at page level */
  contained?: boolean;

  /**
   * Optional category slug (e.g. "cv-strategy").
   * Used to pull hero copy from the canonical BlogCategory metadata.
   */
  categorySlug?: CategorySlug | string;
  /**
   * Optional BlogCategory object. If both category and categorySlug are
   * provided, `category` takes precedence.
   */
  category?: BlogCategory;
}

const props = Astro.props as Props;

const {
  stats = {},
  primaryCta,
  secondaryCta,
  contained = false,
} = props;

// Resolve category metadata (if provided) from props + canonical registry
const categoryMeta: BlogCategory | undefined =
  props.category ??
  (props.categorySlug
    ? getCategory(String(props.categorySlug))
    : undefined);

function fmtDate(d?: string | Date) {
  if (!d) return null;
  try {
    const date = typeof d === "string" ? new Date(d) : d;
    return date.toLocaleDateString("en-KE", {
      year: "numeric",
      month: "short",
    });
  } catch {
    return null;
  }
}

// FP005-05: Resolve hero title/dek from BlogCategory metadata when not explicitly set
const resolvedTitle =
  (typeof props.title === "string" && props.title.trim().length > 0
    ? props.title
    : categoryMeta?.heroTitle ||
      categoryMeta?.name ||
      "Blog category");

const resolvedDek =
  (typeof props.dek === "string" && props.dek.trim().length > 0
    ? props.dek
    : categoryMeta?.heroSubtitle || categoryMeta?.description || undefined);

const lastUpdatedText = fmtDate(stats.lastUpdated);
const statBits = [
  typeof stats.postCount === "number" ? `${stats.postCount} posts` : null,
  lastUpdatedText ? `Updated ${lastUpdatedText}` : null,
  stats.readRange ? stats.readRange : null,
].filter(Boolean) as string[];

const dekId = "category-hero-dek";
const titleId = "category-hero-title";

/**
 * We always render a hero visual:
 * - If a <slot name="media" /> is provided, we use it.
 * - Otherwise we fall back to a default hero image in /public/images,
 *   optionally overridden by BlogCategory.heroImage.
 */
const hasMediaSlot = Astro.slots.has?.("media") === true;
const hasMedia = true; // ensure layout treats hero as media-present

// FP005-05: Prefer category-specific hero image when available
const FALLBACK_HERO =
  categoryMeta?.heroImage?.src ||
  "/assets/images/blog/hero/blog-home-hero.webp"; // safe shared fallback
---

<section
  class="category-hero"
  data-section="category-hero"
  data-contained={String(contained)}
  data-has-media={String(hasMedia)}
  aria-labelledby={titleId}
>
  <link rel="stylesheet" href={css} />

  <div
    class:list={[
      "category-hero__grid",
      hasMedia ? "has-media" : "no-media",
      contained ? "is-contained" : "is-uncontained",
    ]}
  >
    <header class="category-hero__head">
      <p class="category-hero__eyebrow">Blog category</p>

      {/* h1 using global h1 styles via utility + hero-specific styling */}
      <h1 id={titleId} class="category-hero__title section-title h1">
        {resolvedTitle}
      </h1>

      {resolvedDek && (
        <p id={dekId} class="category-hero__dek">
          {resolvedDek}
        </p>
      )}

      {statBits.length > 0 && (
        <ul class="category-hero__stats" aria-label="Category metrics">
          {statBits.map((s) => (
            <li class="category-hero__stat">{s}</li>
          ))}
        </ul>
      )}

      {(primaryCta || secondaryCta) && (
        <div class="category-hero__ctas">
          {primaryCta && (
            <a
              class="btn btn-primary"
              href={primaryCta.href}
              data-cta="category-primary"
              aria-describedby={resolvedDek ? dekId : undefined}
            >
              {primaryCta.label}
            </a>
          )}
          {secondaryCta && (
            <a
              class="btn btn-accent"
              href={secondaryCta.href}
              data-cta="category-secondary"
              aria-describedby={resolvedDek ? dekId : undefined}
            >
              {secondaryCta.label}
            </a>
          )}
        </div>
      )}
    </header>

    <div class="category-hero__media" aria-hidden="true">
      {hasMediaSlot ? (
        <slot name="media" />
      ) : (
        <figure class="category-hero__media-frame">
          <div class="category-hero__media-backdrop" />
          <img
            src={FALLBACK_HERO}
            alt="Curated CV writing and career insights for this category"
            loading="lazy"
            decoding="async"
          />
        </figure>
      )}
    </div>
  </div>
</section>
