---
export interface Cover {
  src: string;
  alt?: string;
  width?: number;
  height?: number;
}

export interface FM {
  title: string;
  description?: string;
  date: string | Date;
  readingTime?: number;
  category?: string;
  cover?: Cover;
}

export interface Post {
  url: string;
  frontmatter: FM;
}

export interface Props {
  posts: Post[];
  pageSize?: number;
  eyebrow?: string;
  title?: string;
  moreHref?: string;
  moreLabel?: string;
  moreAriaLabel?: string;
  ctaClass?: string;
  /** When true, enable client "Load more". Default false because SSG pagination is preferred. */
  clientLoadMore?: boolean;
}

import { categorySlug } from "../../../../lib/slug";
import { getCategory } from "@/lib/blog/categories";
import css from "./PostFeedLatest.css?url";

const {
  posts = [],
  pageSize = 8, // default cap 8
  eyebrow = "From the blog",
  title = "Latest articles",
  moreHref = "/blog/",
  moreLabel = "View all",
  moreAriaLabel,
  ctaClass = "pfl__viewAll",
  clientLoadMore = false,
} = Astro.props as Props;

// Enforce cap at render time unless clientLoadMore is enabled.
const renderList: Post[] = clientLoadMore ? posts : (posts ?? []).slice(0, pageSize);

const fmt = (d: string | Date) =>
  new Date(d).toLocaleDateString("en-KE", {
    year: "numeric",
    month: "short",
    day: "numeric",
  });

/**
 * FP005-07 / taxonomy migration:
 * Resolve category links via canonical BlogCategory metadata where possible.
 * - Normalise frontmatter category with categorySlug().
 * - If that slug matches a known BlogCategory, use its canonical slug.
 * - Otherwise, fall back to the raw slugified value.
 */
const catHref = (p: Post) => {
  const raw = p.frontmatter?.category || "uncategorized";
  const slug = categorySlug(raw);
  const meta = getCategory(slug);
  const resolvedSlug = meta?.slug ?? slug;
  return `/blog/${resolvedSlug}/`;
};
---

<link rel="stylesheet" href={css} />

<section class="pfl" aria-label="Latest articles">
  <div class="container">
    <header class="pfl__head">
      {eyebrow && (
        <p class="pfl__eyebrow label-sm label-caps">
          {eyebrow}
        </p>
      )}
      {title && (
        <h2 class="pfl__title section-title h2">
          {title}
        </h2>
      )}
    </header>

    {/* Grid: CSS handles 1→2→4 columns. 4-up at wide screens per stylesheet. */}
    <div id="pfl-grid" class="pfl__grid" data-page-size={pageSize}>
      {renderList.map((p, idx) => {
        const href = p.url; // canonical URL supplied by parent
        const categoryLink = catHref(p);
        const dt = new Date(p.frontmatter.date);
        const dateIso = isNaN(dt.getTime()) ? undefined : dt.toISOString();

        // If clientLoadMore=false we sliced already; when true, hide beyond pageSize.
        const hiddenClass = clientLoadMore && idx >= pageSize ? "is-hidden" : "";

        return (
          <article
            class={`pfl__card ${hiddenClass}`}
            data-index={idx}
            data-cat={(p.frontmatter?.category ?? "").trim() || "uncategorized"}
          >
            {p.frontmatter?.cover?.src ? (
              <a
                href={href}
                class="pfl__media"
                aria-label={`Read ${p.frontmatter.title}`}
              >
                <img
                  src={p.frontmatter.cover.src}
                  alt={p.frontmatter.cover.alt ?? p.frontmatter.title}
                  width={p.frontmatter.cover.width ?? 640}
                  height={p.frontmatter.cover.height ?? 360}
                  loading={idx < 4 ? "eager" : "lazy"}
                  decoding="async"
                  sizes="(min-width:1280px) 25vw, (min-width:1024px) 25vw, (min-width:640px) 33vw, 100vw"
                  fetchpriority={idx < 2 ? "high" : "low"}
                />
              </a>
            ) : (
              <div class="pfl__media pfl__media--empty" aria-hidden="true" />
            )}

            <div class="pfl__body">
              {p.frontmatter?.category && (
                <p class="pfl__cat">
                  <a
                    href={categoryLink}
                    aria-label={`View ${p.frontmatter.category} posts`}
                  >
                    {p.frontmatter.category}
                  </a>
                </p>
              )}

              <h3 class="pfl__cardTitle line-clamp-2">
                <a
                  href={href}
                  class="pfl__link"
                  aria-label={`Read ${p.frontmatter.title}`}
                >
                  {p.frontmatter.title}
                </a>
              </h3>

              {p.frontmatter?.description && (
                <p class="pfl__excerpt clamp-3">
                  {p.frontmatter.description}
                </p>
              )}

              <p class="pfl__meta">
                {dateIso && (
                  <span class="pfl__metaPill pfl__metaPill--date">
                    <time datetime={dateIso}>{fmt(p.frontmatter.date)}</time>
                  </span>
                )}
                {typeof p.frontmatter?.readingTime === "number" && (
                  <span
                    class="pfl__metaPill pfl__metaPill--read"
                    aria-label={`${p.frontmatter.readingTime} minute read`}
                  >
                    {p.frontmatter.readingTime} min read
                  </span>
                )}
              </p>
            </div>
          </article>
        );
      })}
    </div>

    <div class="pfl__actions">
      {clientLoadMore && posts.length > pageSize && (
        <button
          id="pfl-more"
          class="pfl__loadMore"
          data-cta="blog-load-more"
          type="button"
        >
          Load more
        </button>
      )}

      <a
        href={moreHref}
        aria-label={moreAriaLabel ?? moreLabel}
        class={ctaClass}
        data-cta="blog-view-all"
      >
        {moreLabel}
      </a>
    </div>
  </div>

  <script is:inline>
    (() => {
      const grid = document.getElementById("pfl-grid");
      const btn = document.getElementById("pfl-more");

      // If there is no load-more button or grid, silently exit.
      if (!grid || !btn) return;

      const pageSizeAttr = Number(grid.dataset.pageSize);
      const PAGE_SIZE =
        Number.isFinite(pageSizeAttr) && pageSizeAttr > 0 ? pageSizeAttr : 8;

      let shown = Math.min(PAGE_SIZE, grid.children.length);

      btn.addEventListener(
        "click",
        () => {
          const hiddenCards = Array.from(
            grid.querySelectorAll(".pfl__card.is-hidden"),
          );
          const next = hiddenCards.slice(0, PAGE_SIZE);

          next.forEach((card) => {
            card.classList.remove("is-hidden");
            card.style.contentVisibility = "auto";
          });

          shown += next.length;
          if (shown >= grid.children.length) {
            btn.remove();
          }
        },
        { passive: true },
      );
    })();
  </script>
</section>
