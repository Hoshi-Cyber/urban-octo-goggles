---
/**
 * File: src/pages/blog/[category]/[slug].astro
 *
 * Fix Plan 190 & 190.2: Wire compose components + MDX map (single-post),
 * ensure cover is correctly passed to BlogPost, and wire a visible comments slot.
 *
 * Fix Plan 195: normalized authorSlug model + safe OG image defaults.
 *
 * Fix Plan 205.1: Single Blog Post Layout – data, IA, SEO & migration closure.
 * - Map full BlogPostLayoutProps from frontmatter + content, including:
 *   heroTagline, heroSoftCta, heroImage, introHtml, keyTakeaways,
 *   inlineOffer, socialProofItems, faqItems, finalCta, checklist, relatedArticles.
 * - Align SEO/meta/OG/Twitter + JSON-LD via Seo + ArticleJsonLd components.
 */

import type { CollectionEntry } from "astro:content";
import { getCollection } from "astro:content";

// Layout + page components
import BaseLayout from "@/components/layout/BaseLayout.astro";
import BlogPost from "@/components/blog/base/BlogPost.astro";
import { mdxComponents } from "@/components/blog/compose/mdx";

// SEO components
import Seo from "@/components/seo/Seo.astro";
import ArticleJsonLd from "@/components/seo/ArticleJsonLd/index.astro";

import site from "@/site.config";

// Route params (SSR)
const { category, slug } = Astro.params as { category: string; slug: string };

// Load all posts
const allPosts = await getCollection("blog");

// Helpers
const baseSlug = (p: CollectionEntry<"blog">) => p.slug.split("/").pop()!;
const catFromPath = (p: CollectionEntry<"blog">) =>
  p.slug.includes("/") ? p.slug.split("/")[0] : undefined;

// Find current entry by base slug + category
const entry = allPosts.find((p) => {
  const matchesSlug = baseSlug(p) === slug;
  const entryCat = p.data.category ?? catFromPath(p);
  return matchesSlug && entryCat === category;
});

if (!entry) {
  // Respect trailingSlash: "always"
  return Astro.redirect("/404/");
}

const { Content, headings } = await entry.render();

// Derive category and helpers
const categorySlug = entry.data.category ?? catFromPath(entry);
const entryBaseSlug = baseSlug(entry);

const title = entry.data.title;
const description = entry.data.description;
const tags = entry.data.tags ?? [];
const date = new Date(entry.data.date);
const updated = entry.data.updated ? new Date(entry.data.updated) : null;
const readingTime = entry.data.readingTime ?? null;

// Optional meta overrides from frontmatter
const metaTitle: string | undefined = (entry.data as any).metaTitle ?? undefined;
const metaDescription: string | undefined =
  (entry.data as any).metaDescription ?? undefined;

// Author data (Fix 195-A/B: flattened schema author + authorSlug; URL derived in layout)
const authorName: string | undefined = entry.data.author as string | undefined;
const authorSlug: string | undefined = (entry.data as any).authorSlug ?? undefined;

const resolvedAuthorSlug = authorSlug ?? "mezame-editorial";
const canonicalAuthorUrl = `/about/editorial/${resolvedAuthorSlug}/`;

// Absolute site URL
const siteUrl: string | undefined =
  (site && typeof (site as any).siteUrl === "string" && (site as any).siteUrl) ||
  Astro.site?.origin;

// Canonical (absolute) – handed off to BaseLayout
const pathname = `/blog/${categorySlug}/${entryBaseSlug}/`;
const canonicalAbs =
  (entry.data as any)?.canonical ||
  (siteUrl ? new URL(pathname, siteUrl).toString() : undefined);

// ----- Hero / cover mapping (Fix 205.1 – heroImage as primary) -----

// Raw cover data from frontmatter (legacy support; still passed through to BlogPost)
const cover = (entry.data as any).cover;

// Typed alias used for hero image + preload / JSON-LD image logic
type ImageForMeta =
  | {
      src:
        | string
        | {
            src: string;
            width?: number;
            height?: number;
          };
      alt?: string;
      width?: number;
      height?: number;
    }
  | undefined;

// New hero image field (preferred); fallback to cover for older posts
const heroImage = ((entry.data as any).heroImage ?? cover) as ImageForMeta;

// Derive the hero image URL used by PostCover for LCP/JSON-LD/preload coherence
const heroImageUrl: string | undefined =
  typeof heroImage?.src === "string"
    ? heroImage.src
    : typeof heroImage?.src === "object"
    ? heroImage.src.src
    : undefined;

// Optional alternates for hreflang (array of { hrefLang, href })
type Alternate = { hrefLang: string; href: string };
const alternates = Array.isArray((entry.data as any)?.alternates)
  ? ((entry.data as any).alternates as Alternate[])
  : undefined;

// Build TOC: H2/H3 only (rendered via PostToc inside BlogPost)
const tocHeadings = headings
  .filter((h: any) => h.depth === 2 || h.depth === 3)
  .map((h: any) => ({ depth: h.depth, slug: h.slug, text: h.text }));
const showTOC = tocHeadings.length >= 3;

// Prev/Next within same category by date
const inSameCategory = allPosts
  .filter((p) => (p.data.category ?? catFromPath(p)) === categorySlug)
  .sort(
    (a, b) =>
      new Date(b.data.date).getTime() - new Date(a.data.date).getTime()
  );

const idx = inSameCategory.findIndex((p) => baseSlug(p) === entryBaseSlug);
const prev = idx > 0 ? inSameCategory[idx - 1] : null;
const next =
  idx >= 0 && idx < inSameCategory.length - 1
    ? inSameCategory[idx + 1]
    : null;

// Related posts: same category then tag-overlap score
function overlapScore(a: CollectionEntry<"blog">, b: CollectionEntry<"blog">) {
  const ta = new Set(a.data.tags ?? []);
  const tb = new Set(b.data.tags ?? []);
  let score = 0;
  for (const t of ta) if (tb.has(t)) score++;
  return score;
}

const related = allPosts
  .filter(
    (p) =>
      baseSlug(p) !== entryBaseSlug &&
      (p.data.category ?? catFromPath(p)) === categorySlug
  )
  .map((p) => ({ post: p, score: overlapScore(entry, p) }))
  .filter((x) => x.score > 0 || tags.length === 0)
  .sort(
    (a, b) =>
      b.score - a.score ||
      new Date(b.post.data.date).getTime() -
        new Date(a.post.data.date).getTime()
  )
  .slice(0, 6)
  .map((x) => x.post);

// Deterministic RelatedArticle[] payload for layout (Fix 205.1.6)
type RelatedArticle = {
  title: string;
  url: string;
  category?: string;
  readingTime?: number | null;
  excerpt?: string;
  date: Date;
};

const relatedArticles: RelatedArticle[] = related.map((post) => {
  const cat = post.data.category ?? catFromPath(post);
  const base = baseSlug(post);
  const url = `/blog/${cat}/${base}/`;

  return {
    title: post.data.title,
    url,
    category: cat,
    readingTime: (post.data as any).readingTime ?? null,
    excerpt: post.data.description,
    date: new Date(post.data.date),
  };
});

// ---------- Layout props from frontmatter (Fix 205.1.2) ----------

// Hero copy
const heroTagline = (entry.data as any).heroTagline ?? null;
const heroSoftCta = (entry.data as any).heroSoftCta ?? null;

// Intro slice (HTML string or rich text pre-derived by MDX pipeline)
const introHtml = (entry.data as any).introHtml ?? null;

// Key takeaways – normalized to array when present
const rawKeyTakeaways = (entry.data as any).keyTakeaways;
const keyTakeaways =
  Array.isArray(rawKeyTakeaways)
    ? rawKeyTakeaways
    : rawKeyTakeaways
    ? [rawKeyTakeaways]
    : null;

// Inline offer block
const inlineOffer = (entry.data as any).inlineOffer ?? null;

// Social proof / testimonials
const socialProofItems = (entry.data as any).socialProofItems ?? null;

// FAQ entries
const faqItems = (entry.data as any).faqItems ?? null;

// Final CTA block
const finalCta = (entry.data as any).finalCta ?? null;

// Checklist (implementation steps) – can be list of strings or objects
const checklist = (entry.data as any).checklist ?? null;

// ---------- SEO + JSON-LD wiring (Fix 205.1.5) ----------

const publisherName =
  (site && ((site as any).publisherName || (site as any).orgName)) ||
  new URL(siteUrl || Astro.url).hostname;

const publisherLogoUrl =
  (site && ((site as any).publisherLogo || (site as any).orgLogo)) ||
  undefined;

// Estimate wordCount if not provided: readingTime (min) * 200 wpm
const wordCount =
  (entry.data as any).wordCount ??
  (typeof readingTime === "number"
    ? Math.max(1, Math.round(readingTime * 200))
    : undefined);

// Resolved OG image (Fix 195-E / 205.1.5): ogImage > heroImage > site default
const siteDefaultOg = "/assets/images/og/default-blog.webp";

const ogImage: string | undefined =
  (entry.data as any).ogImage ?? heroImageUrl ?? siteDefaultOg;

// SEO meta title/description (prefer metaTitle/metaDescription when present)
const seoTitle =
  typeof metaTitle === "string" && metaTitle.trim().length > 0
    ? metaTitle
    : title;

const seoDescription =
  typeof metaDescription === "string" && metaDescription.trim().length > 0
    ? metaDescription
    : description;

// Breadcrumbs array for ArticleJsonLd
const breadcrumbs = [
  {
    name: "Home",
    item: siteUrl ? new URL("/", siteUrl).toString() : "/",
    position: 1,
  },
  {
    name: "Blog",
    item: siteUrl ? new URL("/blog/", siteUrl).toString() : "/blog/",
    position: 2,
  },
  {
    name: (categorySlug || "").replaceAll("-", " "),
    item: siteUrl
      ? new URL(`/blog/${categorySlug}/`, siteUrl).toString()
      : `/blog/${categorySlug}/`,
    position: 3,
  },
  {
    name: title,
    item:
      canonicalAbs ||
      (siteUrl ? new URL(pathname, siteUrl).toString() : pathname),
    position: 4,
  },
];

// Props for BlogPost component (now aligned with BlogPostLayoutProps)
const layoutProps = {
  title,
  description,
  category: categorySlug,
  tags,
  date,
  updated,
  readingTime,
  // Legacy hero image support
  cover,
  // TOC + navigation
  tocHeadings,
  showTOC,
  prev,
  next,
  related,
  // Author wiring (Fix 195-B)
  author: authorName,
  authorSlug,
  // Fix Plan 205.1 – extended layout props
  heroTagline,
  heroSoftCta,
  heroImage,
  introHtml,
  keyTakeaways,
  inlineOffer,
  socialProofItems,
  faqItems,
  finalCta,
  checklist,
  relatedArticles,
};
---
<BaseLayout
  title={title}
  description={description}
  canonical={canonicalAbs}
  seo={{ ogImage }}
>
  {/* Core SEO + OG/Twitter */}
  <Seo
    slot="head"
    title={seoTitle}
    description={seoDescription}
    canonicalUrl={canonicalAbs}
    ogType="article"
    ogImage={ogImage}
    siteName={(site as any)?.siteName}
    robots="index,follow,max-snippet:-1,max-image-preview:large,max-video-preview:-1"
    alternates={alternates}
  />

  {/* Structured data (BlogPosting + BreadcrumbList) */}
  {canonicalAbs && (
    <ArticleJsonLd
      slot="head"
      title={title}
      metaTitle={metaTitle}
      description={description}
      metaDescription={metaDescription}
      canonicalUrl={canonicalAbs}
      datePublished={date}
      dateModified={updated}
      inLanguage="en"
      imageUrl={heroImageUrl || ogImage}
      authorName={authorName}
      authorUrl={canonicalAuthorUrl}
      publisherName={publisherName}
      publisherLogoUrl={publisherLogoUrl}
      category={categorySlug}
      tags={tags}
      wordCount={wordCount}
      breadcrumbs={breadcrumbs}
    />
  )}

  {/* LCP image preload (hero-cover aligned with PostCover + JSON-LD) */}
  {(() => {
    const href = heroImageUrl || ogImage || null;

    return href ? (
      <link
        slot="head"
        rel="preload"
        as="image"
        href={href}
        imagesizes="(max-width: 768px) 100vw, 1200px"
        fetchpriority="high"
      />
    ) : null;
  })()}

  {/* Reading progress bar (island) */}
  <div
    id="read-progress"
    class="read-progress"
    aria-hidden="true"
  ></div>
  <script
    type="module"
    src="/src/components/blog/islands/readingProgress.ts"
  ></script>

  <BlogPost {...layoutProps}>
    {/* Article body with MDX shortcodes enabled; BlogPost handles TOC, tags, share, nav, related, lead magnet via compose components */}
    <Content components={mdxComponents} />

    {/* Fix Plan 190.2: ensure Comments slot has visible content */}
    <section slot="comments" class="comments-placeholder">
      <h2 class="h4">Comments</h2>
      <p>
        Comments for this article will be available soon. For now, you can
        reach us via the contact page if you have questions or feedback.
      </p>
    </section>
  </BlogPost>
</BaseLayout>
