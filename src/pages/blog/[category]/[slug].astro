---
// File: src/pages/blog/[category]/[slug].astro
// FP-172: Styling reliability + TOC rendered when headings exist (≥3 H2/H3)

import { getCollection, getEntry } from "astro:content";
import BlogPost from "../../../components/blog/base/BlogPost.astro";
import { prettyCategoryTitle } from "../../../lib/blog/categories";
import {
  categorySlug,
  postSlugFromEntry,
  postUrlFromEntry,
  abs as absUrl,
} from "../../../lib/slug";

export const prerender = true;

/** Build static paths from one source of truth */
export async function getStaticPaths() {
  const posts = await getCollection("blog");
  return posts.map((p) => ({
    params: {
      category: categorySlug((p.data as any)?.category),
      slug: postSlugFromEntry(p.slug),
    },
    props: { slug: p.slug },
  }));
}

/** Load the entry using the collection slug provided via props */
const { props } = Astro;
const entry = await getEntry("blog", props.slug);
if (!entry) {
  return Astro.redirect("/404");
}

/** Render content and collect headings for TOC */
const { Content, headings = [] } = await entry.render();

type PostData = {
  title: string;
  description?: string;
  seo?: any;
  cover?: any;
  ogImage?: any;
  date?: string;
  updated?: string;
  updatedAt?: string;
  author?: string;
  tags?: string[];
  category?: string;
  readingTime?: number;
  readingTimeMinutes?: number;
};
const data = entry.data as PostData;

/** Canonical URL pieces via helpers */
const cat = categorySlug(data.category);
const postPath = postUrlFromEntry(entry);               // /blog/<cat>/<slug>/
const canonical = absUrl(postPath, Astro.site);         // absolute if site is set

/** Media + meta */
const cover = data.cover ?? data.ogImage ?? null;
const coverUrl = typeof cover === "string" ? cover : cover?.src ?? null;
const readingTime = data.readingTime ?? data.readingTimeMinutes ?? null;

/** ---------- FP-172: TOC renders when headings exist (≥3 H2/H3) ---------- */
const tocHeadings = (headings as Array<{ depth: number; slug: string; text: string }> | undefined)
  ?.filter(h => h.depth === 2 || h.depth === 3) ?? [];
const showToc = tocHeadings.length >= 3;

/** ---------- Prev/Next within same category ---------- */
const allPosts = await getCollection("blog");
const inSameCategory = allPosts
  .filter(p => categorySlug((p.data as any)?.category) === cat)
  .filter(p => !!(p.data as any)?.date)
  .sort((a, b) => {
    const da = new Date((a.data as any).date).getTime();
    const db = new Date((b.data as any).date).getTime();
    return da - db; // ascending by date
  });

const idx = inSameCategory.findIndex(p => postSlugFromEntry(p.slug) === postSlugFromEntry(entry.slug));

const prevPost = idx > 0 ? inSameCategory[idx - 1] : null;
const nextPost = idx >= 0 && idx < inSameCategory.length - 1 ? inSameCategory[idx + 1] : null;

const prev = prevPost ? { title: (prevPost.data as any).title, url: postUrlFromEntry(prevPost) } : null;
const next = nextPost ? { title: (nextPost.data as any).title, url: postUrlFromEntry(nextPost) } : null;

/** ---------- Related posts by category + tags overlap ---------- */
const currentTags = new Set((data.tags ?? []).map(t => String(t).toLowerCase()));
function tagOverlapScore(candidateTags: string[] | undefined) {
  if (!candidateTags?.length || currentTags.size === 0) return 0;
  const set = new Set(candidateTags.map(t => t.toLowerCase()));
  let score = 0;
  for (const t of currentTags) if (set.has(t)) score++;
  return score;
}

const relatedCandidates = allPosts
  .filter(p => p.slug !== entry.slug)
  .filter(p => categorySlug((p.data as any)?.category) === cat)
  .map(p => ({
    entry: p,
    score: tagOverlapScore((p.data as any)?.tags),
    dateMs: (p.data as any)?.date ? new Date((p.data as any).date).getTime() : 0
  }))
  .sort((a, b) => {
    // higher tag score first, then newer first
    if (b.score !== a.score) return b.score - a.score;
    return b.dateMs - a.dateMs;
  })
  .slice(0, 6);

/** ---------- JSON-LD ---------- */
const modified = data.updated ?? data.updatedAt ?? data.date ?? undefined;
const breadcrumbs = {
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  itemListElement: [
    { "@type": "ListItem", position: 1, name: "Home", item: absUrl("/", Astro.site) },
    { "@type": "ListItem", position: 2, name: "Blog", item: absUrl("/blog/", Astro.site) },
    { "@type": "ListItem", position: 3, name: prettyCategoryTitle(cat), item: absUrl(`/blog/${cat}/`, Astro.site) },
    { "@type": "ListItem", position: 4, name: data.title, item: canonical },
  ],
};

const articleLd = {
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  mainEntityOfPage: { "@type": "WebPage", "@id": canonical },
  headline: data.title,
  description: data.description || undefined,
  image: coverUrl ? [coverUrl] : undefined,
  datePublished: data.date ? new Date(data.date).toISOString() : undefined,
  dateModified: modified ? new Date(modified).toISOString() : undefined,
  author: data.author ? [{ "@type": "Person", name: data.author }] : undefined,
  articleSection: prettyCategoryTitle(cat),
  keywords: Array.isArray(data.tags) ? data.tags.join(", ") : undefined,
  publisher: { "@type": "Organization", name: "CV Writing Kenya" }
};
---
<BlogPost
  title={data.title}
  description={data.description}
  seo={data.seo}
  date={data.date}
  author={data.author}
  readingTime={readingTime}
  tags={data.tags}
  cover={cover}
  category={prettyCategoryTitle(cat)}
  categoryUrl={`/blog/${cat}/`}
  prev={prev}
  next={next}
>
  <fragment slot="head">
    <link rel="canonical" href={canonical} />
    <meta property="og:url" content={canonical} />
    {coverUrl && <meta property="og:image" content={coverUrl} />}
    <script type="application/ld+json" is:inline>{JSON.stringify(breadcrumbs)}</script>
    <script type="application/ld+json" is:inline>{JSON.stringify(articleLd)}</script>
  </fragment>

  {/* FP-172: Conditional TOC slot (by headings count) */}
  {showToc && tocHeadings.length > 0 && (
    <fragment slot="toc">
      <nav aria-label="Table of contents">
        <ol>
          {tocHeadings.map((h) => (
            <li style={`margin-left:${h.depth === 3 ? "1rem" : "0"};`}>
              <a href={`#${h.slug}`}>{h.text}</a>
            </li>
          ))}
        </ol>
      </nav>
    </fragment>
  )}

  {/* Related posts slot guarded to avoid empty section */}
  {relatedCandidates.length > 0 && (
    <fragment slot="related">
      <ul>
        {relatedCandidates.map(({ entry }) => {
          const e = entry as typeof entry;
          const url = postUrlFromEntry(e);
          const title = (e.data as any).title as string;
          return (<li><a href={url}>{title}</a></li>);
        })}
      </ul>
    </fragment>
  )}

  <Content />
</BlogPost>
