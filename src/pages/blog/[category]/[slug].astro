---
/**
 * File: src/pages/blog/[category]/[slug].astro
 *
 * Single blog post route wired to BlogPost + BlogPostLayout (Fix Plans 190, 195, 205.1, 213, 004, 006).
 */

import type { CollectionEntry } from "astro:content";
import { getCollection } from "astro:content";

// Layout + page components
import BaseLayout from "@/components/layout/BaseLayout.astro";
import BlogPost from "@/components/blog/base/BlogPost.astro";
import { mdxComponents } from "@/components/blog/compose/mdx";

// SEO components
import Seo from "@/components/seo/Seo.astro";
import ArticleJsonLd from "@/components/seo/ArticleJsonLd/index.astro";

import site from "@/site.config";

// Category metadata (Fix Plan 005 – canonical 5-category model)
import { getCategory } from "@/lib/blog/categories";

// Related articles helper (Fix Plan 205.1.6 / 213 / 006)
import { getRelatedArticles } from "@/lib/blog/related";
import type { RelatedArticle } from "@/lib/blog/related";

// Route params (SSR)
const { category, slug } = Astro.params as { category: string; slug: string };

// Resolve canonical category metadata from the central model
const categoryMeta = getCategory(category);

// If the route category does not map to a known category, 404
if (!categoryMeta) {
  // Respect trailingSlash: "always"
  return Astro.redirect("/404/");
}

// Canonical category slug (one of the defined CategorySlug values)
const canonicalCategorySlug = categoryMeta.slug;

// Load all posts
const allPosts = await getCollection("blog");

// Helpers
const baseSlug = (p: CollectionEntry<"blog">) => p.slug.split("/").pop()!;
const catFromPath = (p: CollectionEntry<"blog">) =>
  p.slug.includes("/") ? p.slug.split("/")[0] : undefined;

// Find current entry by base slug + canonical category slug
const entry = allPosts.find((p) => {
  const matchesSlug = baseSlug(p) === slug;
  const entryCat = p.data.category ?? catFromPath(p);
  return matchesSlug && entryCat === canonicalCategorySlug;
});

if (!entry) {
  // Respect trailingSlash: "always"
  return Astro.redirect("/404/");
}

const { Content, headings } = await entry.render();

// Derive category and helpers
// For canonical behaviour, prefer the resolved canonical slug
const categorySlug =
  entry.data.category ?? catFromPath(entry) ?? canonicalCategorySlug;
const entryBaseSlug = baseSlug(entry);

const title = entry.data.title;
const description = entry.data.description;
const tags = entry.data.tags ?? [];
const date = new Date(entry.data.date);
const updated = entry.data.updated ? new Date(entry.data.updated) : null;
const readingTime = entry.data.readingTime ?? null;

// Optional meta overrides from frontmatter
const metaTitle: string | undefined = (entry.data as any).metaTitle ?? undefined;
const metaDescription: string | undefined =
  (entry.data as any).metaDescription ?? undefined;

// Author data (Fix 195-A/B: flattened schema author + authorSlug; URL derived in layout)
const authorName: string | undefined = entry.data.author as string | undefined;
const authorSlug: string | undefined = (entry.data as any).authorSlug ?? undefined;

const resolvedAuthorSlug = authorSlug ?? "mezame-editorial";
const canonicalAuthorUrl = `/about/editorial/${resolvedAuthorSlug}/`;

// Absolute site URL
const siteUrl: string | undefined =
  (site && typeof (site as any).siteUrl === "string" && (site as any).siteUrl) ||
  Astro.site?.origin;

// Canonical (absolute) – handed off to BaseLayout
const pathname = `/blog/${categorySlug}/${entryBaseSlug}/`;
const canonicalAbs =
  (entry.data as any)?.canonical ||
  (siteUrl ? new URL(pathname, siteUrl).toString() : undefined);

// ----- Hero / cover mapping (robust + normalised) -----

type ImageForMeta =
  | {
      src:
        | string
        | {
            src: string;
            width?: number;
            height?: number;
          };
      alt?: string;
      width?: number;
      height?: number;
    }
  | string
  | null
  | undefined;

// Shared fallback image (also used for OG when nothing else is available)
const FALLBACK_HERO_IMAGE = "/assets/images/og/default-blog.webp";

/**
 * Normalise any frontmatter image-ish value into a safe { src, alt, width?, height? } object.
 * Accepts:
 * - string path
 * - Astro image metadata
 * - objects with nested `src.src`
 * - null / undefined → fallback
 */
function normaliseImageForLayout(
  value: ImageForMeta,
  fallbackSrc: string,
  alt: string,
): { src: string; alt: string; width?: number; height?: number } {
  // Case 1: value is a plain string path
  if (typeof value === "string" && value.trim().length > 0) {
    return { src: value, alt };
  }

  if (value && typeof value === "object") {
    // Case 2: value.src is itself an object (Astro image metadata nested)
    if (
      "src" in value &&
      typeof (value as any).src === "object" &&
      (value as any).src &&
      typeof (value as any).src.src === "string"
    ) {
      const inner = (value as any).src;
      return {
        src: inner.src as string,
        alt:
          typeof (value as any).alt === "string" &&
          (value as any).alt.trim().length > 0
            ? (value as any).alt
            : alt,
        width: typeof inner.width === "number" ? inner.width : undefined,
        height: typeof inner.height === "number" ? inner.height : undefined,
      };
    }

    // Case 3: direct Astro image object or { src: string, alt?, width?, height? }
    if ("src" in value && typeof (value as any).src === "string") {
      const v = value as any;
      return {
        src: v.src as string,
        alt:
          typeof v.alt === "string" && v.alt.trim().length > 0 ? v.alt : alt,
        width: typeof v.width === "number" ? v.width : undefined,
        height: typeof v.height === "number" ? v.height : undefined,
      };
    }
  }

  // Case 4: no usable image – fall back to shared default
  return { src: fallbackSrc, alt };
}

/**
 * Robust, future-proof primary image selection:
 *
 * Priority:
 *   1. heroImage (explicit override for article hero)
 *   2. cover     (canonical blog cover)
 *   3. thumbnail (card-specific thumbnail)
 *   4. image     (legacy/general image)
 *   5. ogImage   (SEO/social image)
 *
 * This mirrors the grid/card behaviour (`thumbnail ?? image ?? cover ?? ogImage`)
 * while still respecting an explicit heroImage override when present.
 */
const fmHeroImage = (entry.data as any).heroImage as ImageForMeta;
const fmCover = (entry.data as any).cover as ImageForMeta;
const fmThumbnail = (entry.data as any).thumbnail as ImageForMeta;
const fmImage = (entry.data as any).image as ImageForMeta;
const fmOgImage = (entry.data as any).ogImage as ImageForMeta;

const primaryImageRaw: ImageForMeta =
  fmHeroImage ?? fmCover ?? fmThumbnail ?? fmImage ?? fmOgImage;

// Normalised hero image (used by layout + JSON-LD + preload)
const heroImage = normaliseImageForLayout(
  primaryImageRaw,
  FALLBACK_HERO_IMAGE,
  title,
);

// Keep a `cover` field for backwards-compatibility with existing adapters,
// but align it to the same primary image so BlogPost/BlogPostLayout see
// a single, consistent hero/cover image.
const cover = heroImage;

// Derive the hero image URL used by PostCover for LCP/JSON-LD/preload coherence
const heroImageUrl: string | undefined =
  typeof heroImage.src === "string" ? heroImage.src : undefined;

// Optional alternates for hreflang (array of { hrefLang, href })
type Alternate = { hrefLang: string; href: string };
const alternates = Array.isArray((entry.data as any)?.alternates)
  ? ((entry.data as any).alternates as Alternate[])
  : undefined;

// Build TOC: H2/H3 only (rendered via PostToc inside BlogPost)
const tocHeadings = headings
  .filter((h: any) => h.depth === 2 || h.depth === 3)
  .map((h: any) => ({ depth: h.depth, slug: h.slug, text: h.text }));

// Approximate word count from readingTime (for TOC gating + SEO)
const approxWordCount =
  typeof readingTime === "number"
    ? Math.max(1, Math.round(readingTime * 200))
    : undefined;

// TOC visibility: heading count + approximate length (Fix Plan 213)
const showTOC =
  tocHeadings.length >= 3 &&
  (approxWordCount === undefined || approxWordCount >= 600);

// Prev/Next within same category by date
const inSameCategory = allPosts
  .filter((p) => (p.data.category ?? catFromPath(p)) === categorySlug)
  .sort(
    (a, b) =>
      new Date(b.data.date).getTime() - new Date(a.data.date).getTime(),
  );

const idx = inSameCategory.findIndex((p) => baseSlug(p) === entryBaseSlug);
const prev = idx > 0 ? inSameCategory[idx - 1] : null;
const next =
  idx >= 0 && idx < inSameCategory.length - 1
    ? inSameCategory[idx + 1]
    : null;

// Related posts (entry-level list kept for backward compatibility)
function overlapScore(a: CollectionEntry<"blog">, b: CollectionEntry<"blog">) {
  const ta = new Set(a.data.tags ?? []);
  const tb = new Set(b.data.tags ?? []);
  let score = 0;
  for (const t of ta) if (tb.has(t)) score++;
  return score;
}

const related = allPosts
  .filter(
    (p) =>
      baseSlug(p) !== entryBaseSlug &&
      (p.data.category ?? catFromPath(p)) === categorySlug,
  )
  .map((p) => ({ post: p, score: overlapScore(entry, p) }))
  .filter((x) => x.score > 0 || tags.length === 0)
  .sort(
    (a, b) =>
      b.score - a.score ||
      new Date(b.post.data.date).getTime() -
        new Date(a.post.data.date).getTime(),
  )
  .slice(0, 6)
  .map((x) => x.post);

// Canonical related articles payload for BlogPostLayout & UI (Fix Plan 205.1.6 / 213 / 006)
const relatedArticles: RelatedArticle[] = await getRelatedArticles(entry, {
  limit: 6,
});

// ---------- Layout props from frontmatter (Fix Plan 205.1 / 004) ----------

const heroTagline = (entry.data as any).heroTagline ?? null;
const heroSoftCta = (entry.data as any).heroSoftCta ?? null;
const introHtml = (entry.data as any).introHtml ?? null;

const rawKeyTakeaways = (entry.data as any).keyTakeaways;
const keyTakeaways =
  Array.isArray(rawKeyTakeaways)
    ? rawKeyTakeaways
    : rawKeyTakeaways
    ? [rawKeyTakeaways]
    : null;

const inlineOffer = (entry.data as any).inlineOffer ?? null;
const socialProofItems = (entry.data as any).socialProofItems ?? null;
const faqItems = (entry.data as any).faqItems ?? null;
const finalCta = (entry.data as any).finalCta ?? null;
const checklist = (entry.data as any).checklist ?? null;

/**
 * Fix Plan 004 – Step 5: Route-level layoutPreset bridge
 *
 * - Read optional `layoutPreset` from frontmatter.
 * - Do NOT default here; BlogPost.astro derives a sensible default based on
 *   category when this is undefined.
 * - This keeps route-level aware of the category/slug context (for future
 *   overrides) while deferring preset resolution to the adapter layer.
 */
const layoutPreset =
  (entry.data as any).layoutPreset as
    | "conversionArticle"
    | "editorialArticle"
    | "analysisArticle"
    | "shortInsight"
    | "campaignLanding"
    | undefined;

// ---------- SEO + JSON-LD wiring ----------

const publisherName =
  (site && ((site as any).publisherName || (site as any).orgName)) ||
  new URL(siteUrl || Astro.url).hostname;

const publisherLogoUrl =
  (site && ((site as any).publisherLogo || (site as any).orgLogo)) ||
  undefined;

const wordCount =
  (entry.data as any).wordCount ??
  (typeof readingTime === "number"
    ? Math.max(1, Math.round(readingTime * 200))
    : undefined);

const siteDefaultOg = FALLBACK_HERO_IMAGE;

const ogFromFrontmatter = (entry.data as any).ogImage;
let ogImage: string | undefined;

if (typeof ogFromFrontmatter === "string" && ogFromFrontmatter.trim().length) {
  ogImage = ogFromFrontmatter;
} else if (
  ogFromFrontmatter &&
  typeof ogFromFrontmatter === "object" &&
  typeof (ogFromFrontmatter as any).src === "string"
) {
  ogImage = (ogFromFrontmatter as any).src as string;
} else {
  ogImage = heroImageUrl ?? siteDefaultOg;
}

const seoTitle =
  typeof metaTitle === "string" && metaTitle.trim().length > 0
    ? metaTitle
    : title;

const seoDescription =
  typeof metaDescription === "string" && metaDescription.trim().length > 0
    ? metaDescription
    : description;

const breadcrumbs = [
  {
    name: "Home",
    item: siteUrl ? new URL("/", siteUrl).toString() : "/",
    position: 1,
  },
  {
    name: "Blog",
    item: siteUrl ? new URL("/blog/", siteUrl).toString() : "/blog/",
    position: 2,
  },
  {
    name: (categorySlug || "").replaceAll("-", " "),
    item: siteUrl
      ? new URL(`/blog/${categorySlug}/`, siteUrl).toString()
      : `/blog/${categorySlug}/`,
    position: 3,
  },
  {
    name: title,
    item:
      canonicalAbs ||
      (siteUrl ? new URL(pathname, siteUrl).toString() : pathname),
    position: 4,
  },
];

// Build props for BlogPost adapter (Fix Plan 205.2 + 004 + 006)
const layoutProps = {
  title,
  description,
  category: categorySlug,
  tags,
  date,
  updated,
  readingTime,
  // Now always a safe, primary image, aligned with card logic
  cover,
  tocHeadings,
  showTOC,
  prev,
  next,
  related,
  author: authorName,
  authorSlug,
  heroTagline,
  heroSoftCta,
  heroImage,
  introHtml,
  keyTakeaways,
  inlineOffer,
  socialProofItems,
  faqItems,
  finalCta,
  checklist,
  relatedArticles,
  layoutPreset,
};
---

<BaseLayout
  title={title}
  description={description}
  canonical={canonicalAbs}
  seo={{ ogImage }}
>
  <Seo
    slot="head"
    title={seoTitle}
    description={seoDescription}
    canonicalUrl={canonicalAbs}
    ogType="article"
    ogImage={ogImage}
    siteName={(site as any)?.siteName}
    robots="index,follow,max-snippet:-1,max-image-preview:large,max-video-preview:-1"
    alternates={alternates}
  />

  {canonicalAbs && (
    <ArticleJsonLd
      slot="head"
      title={title}
      metaTitle={metaTitle}
      description={description}
      metaDescription={metaDescription}
      canonicalUrl={canonicalAbs}
      datePublished={date}
      dateModified={updated}
      inLanguage="en"
      imageUrl={heroImageUrl || ogImage}
      authorName={authorName}
      authorUrl={canonicalAuthorUrl}
      publisherName={publisherName}
      publisherLogoUrl={publisherLogoUrl}
      category={categorySlug}
      tags={tags}
      wordCount={wordCount}
      breadcrumbs={breadcrumbs}
    />
  )}

  {(() => {
    const href = heroImageUrl || ogImage || null;

    return href ? (
      <link
        slot="head"
        rel="preload"
        as="image"
        href={href}
        imagesizes="(max-width: 768px) 100vw, 1200px"
        fetchpriority="high"
      />
    ) : null;
  })()}

  <div
    id="read-progress"
    class="read-progress"
    aria-hidden="true"
  ></div>
  <script
    type="module"
    src="/src/components/blog/islands/readingProgress.ts"
  ></script>

  <BlogPost {...layoutProps}>
    <Content components={mdxComponents} />

    <section slot="comments" class="comments-placeholder">
      <h2 class="h4">Comments</h2>
      <p>
        Comments for this article will be available soon. For now, you can
        reach us via the contact page if you have questions or feedback.
      </p>
    </section>
  </BlogPost>
</BaseLayout>
