---
// File: src/pages/blog/[category]/[slug].astro
// Fix Plan 187: Delegate canonical/SEO base to BaseLayout via absolute canonical prop.

import type { CollectionEntry } from "astro:content";
import { getCollection } from "astro:content";

// Layout + page components
import BaseLayout from "@/components/layout/BaseLayout.astro";
import BlogPost from "@/components/blog/base/BlogPost.astro";
import PostNav from "@/components/blog/compose/PostNav/index.astro";
import { mdxComponents } from "@/components/blog/compose/mdx";

import site from "@/site.config";

// Route params (SSR)
const { category, slug } = Astro.params as { category: string; slug: string };

// Load all posts
const allPosts = await getCollection("blog");

// Helpers
const baseSlug = (p: CollectionEntry<"blog">) => p.slug.split("/").pop()!;
const catFromPath = (p: CollectionEntry<"blog">) =>
  p.slug.includes("/") ? p.slug.split("/")[0] : undefined;

// Find current entry by base slug + category
const entry = allPosts.find((p) => {
  const matchesSlug = baseSlug(p) === slug;
  const entryCat = p.data.category ?? catFromPath(p);
  return matchesSlug && entryCat === category;
});

if (!entry) {
  // Respect trailingSlash: "always"
  return Astro.redirect("/404/");
}

const { Content, headings } = await entry.render();

// Derive category and helpers
const categorySlug = entry.data.category ?? catFromPath(entry);
const entryBaseSlug = baseSlug(entry);

const title = entry.data.title;
const description = entry.data.description;
const tags = entry.data.tags ?? [];
const date = new Date(entry.data.date);
const updated = entry.data.updated ? new Date(entry.data.updated) : null;
const readingTime = entry.data.readingTime ?? null;

// Absolute site URL
const siteUrl: string | undefined =
  (site && typeof (site as any).siteUrl === "string" && (site as any).siteUrl) ||
  Astro.site?.origin;

// Canonical (absolute) – handed off to BaseLayout
const pathname = `/blog/${categorySlug}/${entryBaseSlug}/`;
const canonicalAbs =
  (entry.data as any)?.canonical ||
  (siteUrl ? new URL(pathname, siteUrl).toString() : undefined);

// Cover image data
const cover = entry.data.cover as
  | { src: string | { src: string; width?: number; height?: number }; alt?: string; width?: number; height?: number }
  | undefined;

// Optional alternates for hreflang (array of { hrefLang, href })
type Alternate = { hrefLang: string; href: string };
const alternates = Array.isArray((entry.data as any)?.alternates)
  ? ((entry.data as any).alternates as Alternate[])
  : undefined;

// Build TOC: H2/H3 only → use <details> for mobile-friendly collapse
const tocHeadings = headings
  .filter((h: any) => h.depth === 2 || h.depth === 3)
  .map((h: any) => ({ depth: h.depth, slug: h.slug, text: h.text }));
const showTOC = tocHeadings.length >= 3;

// Prev/Next within same category by date
const inSameCategory = allPosts
  .filter((p) => (p.data.category ?? catFromPath(p)) === categorySlug)
  .sort((a, b) => new Date(b.data.date).getTime() - new Date(a.data.date).getTime());

const idx = inSameCategory.findIndex((p) => baseSlug(p) === entryBaseSlug);
const prev = idx > 0 ? inSameCategory[idx - 1] : null;
const next = idx >= 0 && idx < inSameCategory.length - 1 ? inSameCategory[idx + 1] : null;

// Related posts: same category then tag-overlap score
function overlapScore(a: CollectionEntry<"blog">, b: CollectionEntry<"blog">) {
  const ta = new Set(a.data.tags ?? []);
  const tb = new Set(b.data.tags ?? []);
  let score = 0;
  for (const t of ta) if (tb.has(t)) score++;
  return score;
}

const related = allPosts
  .filter(
    (p) =>
      baseSlug(p) !== entryBaseSlug &&
      (p.data.category ?? catFromPath(p)) === categorySlug
  )
  .map((p) => ({ post: p, score: overlapScore(entry, p) }))
  .filter((x) => x.score > 0 || tags.length === 0)
  .sort(
    (a, b) =>
      b.score - a.score ||
      new Date(b.post.data.date).getTime() - new Date(a.post.data.date).getTime()
  )
  .slice(0, 6)
  .map((x) => x.post);

// ---------- JSON-LD ----------
const publisherName =
  (site && ((site as any).publisherName || (site as any).orgName)) ||
  new URL(siteUrl || Astro.url).hostname;

const publisherLogoUrl =
  (site && ((site as any).publisherLogo || (site as any).orgLogo)) || undefined;

const author =
  typeof entry.data.author === "string"
    ? { "@type": "Person", name: entry.data.author }
    : {
        "@type": "Person",
        name: (entry.data as any).author?.name,
        url: (entry.data as any).author?.url,
        ...(Array.isArray((entry.data as any).author?.sameAs) &&
        (entry.data as any).author?.sameAs.length
          ? { sameAs: (entry.data as any).author?.sameAs }
          : {}),
      };

// Estimate wordCount if not provided: readingTime (min) * 200 wpm
const wordCount =
  (entry.data as any).wordCount ??
  (typeof readingTime === "number" ? Math.max(1, Math.round(readingTime * 200)) : undefined);

const jsonLd: Record<string, any> = {
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  headline: title,
  description,
  datePublished: date.toISOString(),
  ...(updated ? { dateModified: updated.toISOString() } : {}),
  inLanguage: "en",
  mainEntityOfPage: canonicalAbs,
  image:
    (entry.data as any).ogImage ||
    (typeof cover?.src === "string"
      ? cover?.src
      : typeof cover?.src === "object"
      ? cover?.src.src
      : undefined),
  author,
  publisher: {
    "@type": "Organization",
    name: publisherName,
    ...(publisherLogoUrl
      ? { logo: { "@type": "ImageObject", url: String(publisherLogoUrl) } }
      : {}),
  },
  articleSection: categorySlug,
  keywords: tags.join(", "),
  ...(wordCount ? { wordCount } : {}),
};

// Breadcrumb JSON-LD (visible nav parity)
const breadcrumbsLd = {
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  itemListElement: [
    { "@type": "ListItem", position: 1, name: "Home",  item: siteUrl ? new URL("/", siteUrl).toString() : "/" },
    { "@type": "ListItem", position: 2, name: "Blog",  item: siteUrl ? new URL("/blog/", siteUrl).toString() : "/blog/" },
    { "@type": "ListItem", position: 3, name: (categorySlug || "").replaceAll("-", " "), item: siteUrl ? new URL(`/blog/${categorySlug}/`, siteUrl).toString() : `/blog/${categorySlug}/` },
    { "@type": "ListItem", position: 4, name: title, item: canonicalAbs || pathname }
  ],
};

// Props for BlogPost component
const layoutProps = {
  title,
  description,
  category: categorySlug,
  tags,
  date,
  updated,
  readingTime,
  cover,
  tocHeadings,
  showTOC,
  prev,
  next,
  related,
};
---
<BaseLayout
  title={title}
  description={description}
  canonical={canonicalAbs}
  seo={{ ogImage: (entry.data as any)?.ogImage }}
>
  <!-- Robots policy -->
  <meta
    slot="head"
    name="robots"
    content="index,follow,max-snippet:-1,max-image-preview:large,max-video-preview:-1"
  />

  <!-- Optional hreflang set when alternates provided -->
  {alternates &&
    alternates.map((alt) => (
      <link slot="head" rel="alternate" hreflang={alt.hrefLang} href={alt.href} />
    ))}

  <!-- LCP image preload (only one) -->
  {(() => {
    const fm = entry.data as any;
    const href =
      typeof cover?.src === "string"
        ? cover.src
        : typeof cover?.src === "object"
        ? cover.src.src
        : fm?.ogImage ?? null;

    const srcset: string | undefined = Array.isArray(fm?.coverSrcset)
      ? (fm.coverSrcset as string[]).join(", ")
      : typeof fm?.coverSrcset === "string"
      ? (fm.coverSrcset as string)
      : undefined;

    return href ? (
      <link
        slot="head"
        rel="preload"
        as="image"
        href={href}
        {...(srcset ? { imagesrcset: srcset } : {})}
        imagesizes="(max-width: 768px) 100vw, 1200px"
        fetchpriority="high"
      />
    ) : null;
  })()}

  <!-- Structured data -->
  <script slot="head" type="application/ld+json">
    {JSON.stringify(jsonLd)}
  </script>
  <script slot="head" type="application/ld+json">
    {JSON.stringify(breadcrumbsLd)}
  </script>

  <!-- Article-specific Open Graph/Twitter (BaseLayout already sets url/image/title/description) -->
  <meta slot="head" property="og:type" content="article" />
  {site?.siteName && <meta slot="head" property="og:site_name" content={(site as any).siteName} />}
  <meta slot="head" name="twitter:card" content="summary_large_image" />

  <!-- Reading progress bar (island) -->
  <div id="read-progress" class="read-progress" aria-hidden="true"></div>
  <script type="module" src="/src/components/blog/islands/readingProgress.ts"></script>

  <BlogPost {...layoutProps}>
    {/* TOC slot — collapsible details */}
    {showTOC && (
      <Fragment slot="toc">
        <details class="toc-details">
          <summary>Table of contents</summary>
          <ol class="toc-list">
            {tocHeadings.map((h) => (
              <li class={`d${h.depth}`}>
                <a href={`#${h.slug}`}>{h.text}</a>
              </li>
            ))}
          </ol>
        </details>
      </Fragment>
    )}

    {/* Article body with MDX shortcodes enabled */}
    <section class="post__content prose">
      <Content components={mdxComponents} />
    </section>

    {/* Mid-content inline CTA (one only, with UTM) */}
    <section class="post__inlineCta container" style="margin-block: var(--space-8);">
      <div class="card">
        <h2 class="h4">Ready for a CV upgrade?</h2>
        <p>Get a professional rewrite tailored for ATS and recruiters.</p>
        <a
          class="btn btn-primary"
          href="/services/cv-rewrite?utm_source=blog&utm_medium=post&utm_campaign=inline-cta"
        >Book now</a>
      </div>
    </section>

    {/* Lead magnet slot */}
    <Fragment slot="leadmagnet">
      <section id="leadmagnet" aria-label="Subscribe for the CV Optimization PDF" class="container">
        <form method="post" action="/api/subscribe/">
          <label for="email">Email</label>
          <input id="email" name="email" type="email" autocomplete="email" required inputmode="email" />
          <button type="submit" class="btn btn-primary">Get the guide</button>
          <p class="privacy-note">We respect your privacy.</p>
        </form>
      </section>
    </Fragment>

    {/* Related slot */}
    {related.length > 0 && (
      <Fragment slot="related">
        <ul class="post__relatedList">
          {related.map((p) => {
            const url = `/blog/${p.data.category ?? catFromPath(p)}/${baseSlug(p)}/`;
            return (
              <li>
                <a href={url}>{p.data.title}</a>
              </li>
            );
          })}
        </ul>
      </Fragment>
    )}

    {/* Prev/Next slot */}
    <Fragment slot="nav">
      <PostNav prev={prev} next={next} />
    </Fragment>
  </BlogPost>
</BaseLayout>

<style>
/* Page-scoped utilities for slots. Main styling lives in BlogPost.css */
.toc-list { list-style: none; margin: 0; padding: 0 var(--space-2) var(--space-2) var(--space-2); }
.toc-list li { margin: 0.25rem 0; }
.toc-list li.d3 { padding-left: 0.75rem; }
.post__relatedList { list-style: none; padding: 0; margin: 0; display: grid; gap: 0.5rem; }

/* Simple inline CTA card */
.post__inlineCta .card {
  padding: clamp(16px, 2.5vw, 24px);
  border: 1px solid color-mix(in oklab, var(--color-primary) 16%, transparent);
  border-radius: var(--radius-lg);
  background: var(--color-surface);
  box-shadow: var(--shadow-sm);
}
</style>
