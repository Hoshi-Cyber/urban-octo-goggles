---
/**
 * File: src/pages/blog/[category]/[slug].astro
 * Fix Plan 190 & 190.2: Wire compose components + MDX map (single-post),
 * ensure cover is correctly passed to BlogPost, and wire a visible comments slot.
 */

import type { CollectionEntry } from "astro:content";
import { getCollection } from "astro:content";

// Layout + page components
import BaseLayout from "@/components/layout/BaseLayout.astro";
import BlogPost from "@/components/blog/base/BlogPost.astro";
import { mdxComponents } from "@/components/blog/compose/mdx";

import site from "@/site.config";

// Route params (SSR)
const { category, slug } = Astro.params as { category: string; slug: string };

// Load all posts
const allPosts = await getCollection("blog");

// Helpers
const baseSlug = (p: CollectionEntry<"blog">) => p.slug.split("/").pop()!;
const catFromPath = (p: CollectionEntry<"blog">) =>
  p.slug.includes("/") ? p.slug.split("/")[0] : undefined;

// Find current entry by base slug + category
const entry = allPosts.find((p) => {
  const matchesSlug = baseSlug(p) === slug;
  const entryCat = p.data.category ?? catFromPath(p);
  return matchesSlug && entryCat === category;
});

if (!entry) {
  // Respect trailingSlash: "always"
  return Astro.redirect("/404/");
}

const { Content, headings } = await entry.render();

// Derive category and helpers
const categorySlug = entry.data.category ?? catFromPath(entry);
const entryBaseSlug = baseSlug(entry);

const title = entry.data.title;
const description = entry.data.description;
const tags = entry.data.tags ?? [];
const date = new Date(entry.data.date);
const updated = entry.data.updated ? new Date(entry.data.updated) : null;
const readingTime = entry.data.readingTime ?? null;

// Absolute site URL
const siteUrl: string | undefined =
  (site && typeof (site as any).siteUrl === "string" && (site as any).siteUrl) ||
  Astro.site?.origin;

// Canonical (absolute) â€“ handed off to BaseLayout
const pathname = `/blog/${categorySlug}/${entryBaseSlug}/`;
const canonicalAbs =
  (entry.data as any)?.canonical ||
  (siteUrl ? new URL(pathname, siteUrl).toString() : undefined);

// Raw cover data from frontmatter (passed through to BlogPost)
const cover = (entry.data as any).cover;

// Typed alias used for preload / JSON-LD image logic
type CoverForMeta =
  | {
      src:
        | string
        | {
            src: string;
            width?: number;
            height?: number;
          };
      alt?: string;
      width?: number;
      height?: number;
    }
  | undefined;

const coverForMeta = cover as CoverForMeta;

// Optional alternates for hreflang (array of { hrefLang, href })
type Alternate = { hrefLang: string; href: string };
const alternates = Array.isArray((entry.data as any)?.alternates)
  ? ((entry.data as any).alternates as Alternate[])
  : undefined;

// Build TOC: H2/H3 only (rendered via PostToc inside BlogPost)
const tocHeadings = headings
  .filter((h: any) => h.depth === 2 || h.depth === 3)
  .map((h: any) => ({ depth: h.depth, slug: h.slug, text: h.text }));
const showTOC = tocHeadings.length >= 3;

// Prev/Next within same category by date
const inSameCategory = allPosts
  .filter((p) => (p.data.category ?? catFromPath(p)) === categorySlug)
  .sort(
    (a, b) =>
      new Date(b.data.date).getTime() - new Date(a.data.date).getTime()
  );

const idx = inSameCategory.findIndex((p) => baseSlug(p) === entryBaseSlug);
const prev = idx > 0 ? inSameCategory[idx - 1] : null;
const next =
  idx >= 0 && idx < inSameCategory.length - 1
    ? inSameCategory[idx + 1]
    : null;

// Related posts: same category then tag-overlap score
function overlapScore(a: CollectionEntry<"blog">, b: CollectionEntry<"blog">) {
  const ta = new Set(a.data.tags ?? []);
  const tb = new Set(b.data.tags ?? []);
  let score = 0;
  for (const t of ta) if (tb.has(t)) score++;
  return score;
}

const related = allPosts
  .filter(
    (p) =>
      baseSlug(p) !== entryBaseSlug &&
      (p.data.category ?? catFromPath(p)) === categorySlug
  )
  .map((p) => ({ post: p, score: overlapScore(entry, p) }))
  .filter((x) => x.score > 0 || tags.length === 0)
  .sort(
    (a, b) =>
      b.score - a.score ||
      new Date(b.post.data.date).getTime() -
        new Date(a.post.data.date).getTime()
  )
  .slice(0, 6)
  .map((x) => x.post);

// ---------- JSON-LD ----------
const publisherName =
  (site && ((site as any).publisherName || (site as any).orgName)) ||
  new URL(siteUrl || Astro.url).hostname;

const publisherLogoUrl =
  (site && ((site as any).publisherLogo || (site as any).orgLogo)) ||
  undefined;

const author =
  typeof entry.data.author === "string"
    ? { "@type": "Person", name: entry.data.author }
    : {
        "@type": "Person",
        name: (entry.data as any).author?.name,
        url: (entry.data as any).author?.url,
        ...(Array.isArray((entry.data as any).author?.sameAs) &&
        (entry.data as any).author?.sameAs.length
          ? { sameAs: (entry.data as any).author?.sameAs }
          : {}),
      };

// Estimate wordCount if not provided: readingTime (min) * 200 wpm
const wordCount =
  (entry.data as any).wordCount ??
  (typeof readingTime === "number"
    ? Math.max(1, Math.round(readingTime * 200))
    : undefined);

const jsonLd: Record<string, any> = {
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  headline: title,
  description,
  datePublished: date.toISOString(),
  ...(updated ? { dateModified: updated.toISOString() } : {}),
  inLanguage: "en",
  mainEntityOfPage: canonicalAbs,
  image:
    (entry.data as any).ogImage ||
    (typeof coverForMeta?.src === "string"
      ? coverForMeta.src
      : typeof coverForMeta?.src === "object"
      ? coverForMeta.src.src
      : undefined),
  author,
  publisher: {
    "@type": "Organization",
    name: publisherName,
    ...(publisherLogoUrl
      ? {
          logo: {
            "@type": "ImageObject",
            url: String(publisherLogoUrl),
          },
        }
      : {}),
  },
  articleSection: categorySlug,
  keywords: tags.join(", "),
  ...(wordCount ? { wordCount } : {}),
};

// Breadcrumb JSON-LD (visible nav parity)
const breadcrumbsLd = {
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  itemListElement: [
    {
      "@type": "ListItem",
      position: 1,
      name: "Home",
      item: siteUrl ? new URL("/", siteUrl).toString() : "/",
    },
    {
      "@type": "ListItem",
      position: 2,
      name: "Blog",
      item: siteUrl
        ? new URL("/blog/", siteUrl).toString()
        : "/blog/",
    },
    {
      "@type": "ListItem",
      position: 3,
      name: (categorySlug || "").replaceAll("-", " "),
      item: siteUrl
        ? new URL(`/blog/${categorySlug}/`, siteUrl).toString()
        : `/blog/${categorySlug}/`,
    },
    {
      "@type": "ListItem",
      position: 4,
      name: title,
      item: canonicalAbs || pathname,
    },
  ],
};

// Props for BlogPost component
const layoutProps = {
  title,
  description,
  category: categorySlug,
  tags,
  date,
  updated,
  readingTime,
  // Pass raw cover object directly from frontmatter (Fix Plan 190.2)
  cover,
  tocHeadings,
  showTOC,
  prev,
  next,
  related,
};
---
<BaseLayout
  title={title}
  description={description}
  canonical={canonicalAbs}
  seo={{ ogImage: (entry.data as any)?.ogImage }}
>
  <!-- Robots policy -->
  <meta
    slot="head"
    name="robots"
    content="index,follow,max-snippet:-1,max-image-preview:large,max-video-preview:-1"
  />

  <!-- Optional hreflang set when alternates provided -->
  {alternates &&
    alternates.map((alt) => (
      <link
        slot="head"
        rel="alternate"
        hreflang={alt.hrefLang}
        href={alt.href}
      />
    ))}

  <!-- LCP image preload (only one) -->
  {(() => {
    const fm = entry.data as any;
    const href =
      typeof coverForMeta?.src === "string"
        ? coverForMeta.src
        : typeof coverForMeta?.src === "object"
        ? coverForMeta.src.src
        : fm?.ogImage ?? null;

    const srcset: string | undefined = Array.isArray(fm?.coverSrcset)
      ? (fm.coverSrcset as string[]).join(", ")
      : typeof fm?.coverSrcset === "string"
      ? (fm.coverSrcset as string)
      : undefined;

    return href ? (
      <link
        slot="head"
        rel="preload"
        as="image"
        href={href}
        {...(srcset ? { imagesrcset: srcset } : {})}
        imagesizes="(max-width: 768px) 100vw, 1200px"
        fetchpriority="high"
      />
    ) : null;
  })()}

  <!-- Structured data -->
  <script slot="head" type="application/ld+json">
    {JSON.stringify(jsonLd)}
  </script>
  <script slot="head" type="application/ld+json">
    {JSON.stringify(breadcrumbsLd)}
  </script>

  <!-- Article-specific Open Graph/Twitter (BaseLayout already sets url/image/title/description) -->
  <meta slot="head" property="og:type" content="article" />
  {site?.siteName && (
    <meta
      slot="head"
      property="og:site_name"
      content={(site as any).siteName}
    />
  )}
  <meta slot="head" name="twitter:card" content="summary_large_image" />

  <!-- Reading progress bar (island) -->
  <div
    id="read-progress"
    class="read-progress"
    aria-hidden="true"
  ></div>
  <script
    type="module"
    src="/src/components/blog/islands/readingProgress.ts"
  ></script>

  <BlogPost {...layoutProps}>
    {/* Article body with MDX shortcodes enabled; BlogPost handles TOC, tags, share, nav, related, lead magnet via compose components */}
    <Content components={mdxComponents} />

    {/* Fix Plan 190.2: ensure Comments slot has visible content */}
    <section slot="comments" class="comments-placeholder">
      <h2 class="h4">Comments</h2>
      <p>
        Comments for this article will be available soon. For now, you can
        reach us via the contact page if you have questions or feedback.
      </p>
    </section>
  </BlogPost>
</BaseLayout>
